        shell: python
        run: |
          import os
          import requests
          from bs4 import BeautifulSoup
          from github import Github, GithubException
          from packaging import version  # 用于版本比较，需要 pip install packaging

          quark_cookie_str = os.getenv("QUARK_COOKIE")
          url = os.getenv("APK_URL")  # 可以设为 https://pan.quark.cn/s/cb0ee2b9ac64#/list/share/f0c75c96e96e4310b96383b4b22040e3
          if not quark_cookie_str or '=' not in quark_cookie_str:
              print("QUARK_COOKIE 格式错误，请检查 Secrets 设置")
              exit(1)

          cookie_key, cookie_value = quark_cookie_str.split('=', 1)
          cookies = {cookie_key.strip(): cookie_value.strip()}

          last_version_file = ".last_version"

          def get_latest_apk():
              try:
                  headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"}
                  resp = requests.get(url, cookies=cookies, headers=headers, timeout=20, allow_redirects=True)
                  resp.raise_for_status()

                  print("页面状态码:", resp.status_code)
                  print("页面长度:", len(resp.text))
                  print("是否含违规提示:", "违规" in resp.text or "封禁" in resp.text)
                  # print("页面前1500字符:", resp.text[:1500])  # 调试时打开，日志会很长

                  soup = BeautifulSoup(resp.text, "html.parser")

                  # 提取可能版本文件夹（如 3.6.6、上传到当前目录 3.6.2）
                  version_folders = []
                  candidates = soup.find_all(['div', 'span', 'td', 'a'], string=lambda t: t and ('3.' in t or t.strip().replace('.', '').isdigit()))

                  for elem in candidates:
                      text = elem.get_text(strip=True)
                      if text and (text.startswith('3.') or (text.isdigit() and len(text) > 2)):  # 粗匹配版本/日期
                          version_folders.append(text)

                  # 也尝试从 class 或其他标签
                  for row in soup.find_all(['tr', 'div', 'li']):
                      name = row.get_text(strip=True)
                      if '上传到当前目录' in name or '历史版本' in name:
                          parts = name.split()
                          for p in parts:
                              if p.count('.') == 1 and p.replace('.', '').isdigit():
                                  version_folders.append(p)

                  version_folders = list(set(version_folders))  # 去重
                  print("检测到的可能版本/文件夹:", version_folders)

                  if not version_folders:
                      print("未找到任何版本文件夹或 .apk 相关内容")
                      return

                  # 按版本号排序取最新（使用 packaging.version）
                  def parse_ver(v):
                      try:
                          return version.parse(v)
                      except:
                          return version.parse("0.0")

                  latest_folder = max(version_folders, key=parse_ver)
                  print(f"最新检测版本文件夹: {latest_folder}")

                  last_version = None
                  if os.path.exists(last_version_file):
                      with open(last_version_file, "r", encoding="utf-8") as f:
                          last_version = f.read().strip()

                  if latest_folder != last_version:
                      print(f"发现新版本: {latest_folder}")
                      with open(last_version_file, "w", encoding="utf-8") as f:
                          f.write(latest_folder)

                      # 这里假设 APK 在该文件夹下，但当前链接无法获取具体链接
                      # 未来可改成构造子URL 或 请求 API 获取文件列表
                      print("警告: 当前链接受封禁，无法获取文件夹内 APK 下载链接")
                      print("需等链接恢复，或改用夸克 API / 客户端方式")
                      # download_and_upload(...)  # 如果有具体 href 可调用
                  else:
                      print("没有新版本")

              except Exception as e:
                  print(f"获取/解析失败: {type(e).__name__} {str(e)}")

          # download_and_upload 函数保持原样（但当前用不到，因为无 href）
          def download_and_upload(href, version_str):
              # ... (你的原函数，略)

          if __name__ == "__main__":
              get_latest_apk()
