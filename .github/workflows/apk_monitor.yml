name: Monitor and Upload APK

on:
  workflow_dispatch:  # 先手动测试，成功后再改回 schedule
  # schedule:
  #   - cron: '0 * * * *'

jobs:
  check_apk:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 PyGithub packaging

      - name: Run APK monitor script
        env:
          QUARK_COOKIE: ${{ secrets.QUARK_COOKIE }}
          APK_URL: 'https://pan.quark.cn/s/cb0ee2b9ac64#/list/share/f0c75c96e96e4310b96383b4b22040e3'  # 2号链接，含版本文件夹
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: python
        run: |
          import os
          import requests
          from bs4 import BeautifulSoup
          from github import Github, GithubException
          from packaging import version as ver_parser

          quark_cookie_str = os.getenv("QUARK_COOKIE")
          url = os.getenv("APK_URL")

          if not quark_cookie_str:
              print("QUARK_COOKIE 未设置，请检查 Secrets")
              exit(1)

          cookies = {}
          for part in quark_cookie_str.split(';'):
              part = part.strip()
              if '=' in part:
                  key, value = part.split('=', 1)
                  cookies[key] = value

          last_version_file = ".last_version"

          def get_latest_apk():
              try:
                  headers = {
                      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                      "Referer": "https://pan.quark.cn/"
                  }
                  resp = requests.get(url, cookies=cookies, headers=headers, timeout=30, allow_redirects=True)
                  resp.raise_for_status()

                  print(f"页面状态码: {resp.status_code}")
                  print(f"响应长度: {len(resp.text)}")
                  print(f"是否含封禁提示: {'违规' in resp.text or '封禁' in resp.text}")

                  soup = BeautifulSoup(resp.text, "html.parser")

                  # 打印所有可见文本，便于调试
                  all_text = ' '.join(soup.stripped_strings)
                  print("页面所有可见文本预览 (前 500 字):")
                  print(all_text[:500] + "..." if len(all_text) > 500 else all_text)

                  version_candidates = []

                  # 从所有文本中提取可能版本（如 3.6.6, 3.9.7, 20260129）
                  for text in soup.stripped_strings:
                      text = text.strip()
                      if not text:
                          continue
                      # 匹配 x.y.z 格式
                      if text.count('.') == 2 and all(part.isdigit() for part in text.split('.')):
                          version_candidates.append(text)
                      # 匹配纯数字长串（如日期）
                      elif text.isdigit() and len(text) >= 6:
                          version_candidates.append(text)
                      # 从 “上传到当前目录 X.Y.Z” 提取
                      if '上传到当前目录' in text:
                          parts = text.split()
                          for p in parts:
                              if p.count('.') == 2 and all(part.isdigit() for part in p.split('.')):
                                  version_candidates.append(p)

                  version_candidates = list(set(version_candidates))
                  print("提取到的可能版本号/文件夹:", version_candidates)

                  if not version_candidates:
                      print("未提取到任何版本信息")
                      return

                  # 排序取最新
                  def safe_parse(v):
                      try:
                          if '.' in v:
                              return ver_parser.parse(v)
                          else:
                              return int(v)  # 日期数字越大越新
                      except:
                          return ver_parser.parse("0.0.0")

                  latest_version = max(version_candidates, key=safe_parse)
                  print(f"判定最新版本: {latest_version}")

                  last_version = None
                  if os.path.exists(last_version_file):
                      with open(last_version_file, "r", encoding="utf-8") as f:
                          last_version = f.read().strip()

                  if latest_version != last_version:
                      print(f"发现新版本: {latest_version}")
                      with open(last_version_file, "w", encoding="utf-8") as f:
                          f.write(latest_version)
                      # 当前无 APK href，无法下载；可作为版本变更通知
                      print("注意: 当前页面无直接 APK 下载链接（列表为空），仅监控版本文件夹变化。")
                  else:
                      print("没有新版本")

              except Exception as e:
                  print(f"请求/解析失败: {type(e).__name__} - {str(e)}")

          if __name__ == "__main__":
              get_latest_apk()
